[
  {
    "slug": "two-sum",
    "title": "Two Sum",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Hash Table"
    ],
    "companies": [],
    "tags": [
      "Array",
      "Hash Table"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "nums[0] + nums[1] == 9"
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Only one valid answer exists."
    ],
    "testCases": [
      {
        "input": {
          "nums": [
            2,
            7,
            11,
            15
          ],
          "target": 9
        },
        "expected": [
          0,
          1
        ]
      },
      {
        "input": {
          "nums": [
            3,
            2,
            4
          ],
          "target": 6
        },
        "expected": [
          1,
          2
        ]
      },
      {
        "input": {
          "nums": [
            3,
            3
          ],
          "target": 6
        },
        "expected": [
          0,
          1
        ]
      },
      {
        "input": {
          "nums": [
            -1,
            -2,
            -3,
            -4,
            -5
          ],
          "target": -8
        },
        "expected": [
          2,
          4
        ]
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ],
          "target": 9
        },
        "expected": [
          3,
          4
        ]
      },
      {
        "input": {
          "nums": [
            -1000000,
            1000000,
            0,
            500000,
            -500000
          ],
          "target": 0
        },
        "expected": [
          0,
          1
        ]
      },
      {
        "input": {
          "nums": [
            0,
            4,
            3,
            0
          ],
          "target": 0
        },
        "expected": [
          0,
          3
        ]
      },
      {
        "input": {
          "nums": [
            1,
            999999999
          ],
          "target": 1000000000
        },
        "expected": [
          0,
          1
        ]
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            3
          ],
          "target": 5
        },
        "expected": [
          19,
          20
        ]
      }
    ],
    "acceptanceRate": 47,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "valid-palindrome",
    "title": "Valid Palindrome",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
    "difficulty": "Easy",
    "topics": [
      "Two Pointers",
      "String"
    ],
    "companies": [],
    "tags": [
      "Two Pointers",
      "String"
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "amanaplanacanalpanama is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "raceacar is not a palindrome."
      },
      {
        "input": "s = \" \"",
        "output": "true",
        "explanation": "Empty string reads same forward and backward."
      }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters."
    ],
    "testCases": [
      {
        "input": {
          "s": "A man, a plan, a canal: Panama"
        },
        "expected": true
      },
      {
        "input": {
          "s": "race a car"
        },
        "expected": false
      },
      {
        "input": {
          "s": " "
        },
        "expected": true
      },
      {
        "input": {
          "s": "ab_a"
        },
        "expected": true
      },
      {
        "input": {
          "s": "0P"
        },
        "expected": false
      },
      {
        "input": {
          "s": ""
        },
        "expected": true
      },
      {
        "input": {
          "s": ".,;:!@#$%^&*()"
        },
        "expected": true
      },
      {
        "input": {
          "s": "1a2b2A1"
        },
        "expected": true
      },
      {
        "input": {
          "s": "a"
        },
        "expected": true
      },
      {
        "input": {
          "s": "Was it a car or a cat I saw?"
        },
        "expected": true
      },
      {
        "input": {
          "s": "No 'x' in Nixon"
        },
        "expected": true
      }
    ],
    "acceptanceRate": 42,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "reverse-linked-list",
    "title": "Reverse Linked List",
    "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "companies": [],
    "tags": [
      "Linked List",
      "Recursion"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]"
      },
      {
        "input": "head = []",
        "output": "[]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "testCases": [
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "expected": [
          5,
          4,
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2
          ]
        },
        "expected": [
          2,
          1
        ]
      },
      {
        "input": {
          "head": []
        },
        "expected": []
      },
      {
        "input": {
          "head": [
            1
          ]
        },
        "expected": [
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3
          ]
        },
        "expected": [
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ]
        },
        "expected": [
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            1,
            1,
            1
          ]
        },
        "expected": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "input": {
          "head": [
            -5,
            -3,
            -1,
            0,
            2,
            4
          ]
        },
        "expected": [
          4,
          2,
          0,
          -1,
          -3,
          -5
        ]
      }
    ],
    "acceptanceRate": 68,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "max-depth-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "difficulty": "Medium",
    "topics": [
      "Tree",
      "DFS",
      "BFS"
    ],
    "companies": [],
    "tags": [
      "Tree",
      "DFS",
      "BFS"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3"
      },
      {
        "input": "root = [1,null,2]",
        "output": "2"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      {
        "input": {
          "root": [
            3,
            9,
            20,
            null,
            null,
            15,
            7
          ]
        },
        "expected": 3
      },
      {
        "input": {
          "root": [
            1,
            null,
            2
          ]
        },
        "expected": 2
      },
      {
        "input": {
          "root": []
        },
        "expected": 0
      },
      {
        "input": {
          "root": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "expected": 3
      },
      {
        "input": {
          "root": [
            1
          ]
        },
        "expected": 1
      },
      {
        "input": {
          "root": [
            1,
            2,
            null,
            3,
            null,
            4,
            null,
            5
          ]
        },
        "expected": 5
      },
      {
        "input": {
          "root": [
            1,
            null,
            2,
            null,
            3,
            null,
            4
          ]
        },
        "expected": 4
      },
      {
        "input": {
          "root": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ]
        },
        "expected": 3
      },
      {
        "input": {
          "root": [
            1,
            2,
            3,
            4,
            null,
            null,
            null,
            5,
            null,
            null,
            null,
            null,
            null,
            null,
            null
          ]
        },
        "expected": 4
      }
    ],
    "acceptanceRate": 72,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "best-time-to-buy-sell",
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.",
    "difficulty": "Hard",
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "companies": [],
    "tags": [
      "Array",
      "Dynamic Programming"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (1), sell on day 5 (6), profit = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profit possible."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "testCases": [
      {
        "input": {
          "prices": [
            7,
            1,
            5,
            3,
            6,
            4
          ]
        },
        "expected": 5
      },
      {
        "input": {
          "prices": [
            7,
            6,
            4,
            3,
            1
          ]
        },
        "expected": 0
      },
      {
        "input": {
          "prices": [
            1,
            2
          ]
        },
        "expected": 1
      },
      {
        "input": {
          "prices": [
            2,
            4,
            1
          ]
        },
        "expected": 2
      },
      {
        "input": {
          "prices": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        "expected": 4
      },
      {
        "input": {
          "prices": [
            5
          ]
        },
        "expected": 0
      },
      {
        "input": {
          "prices": [
            3,
            3,
            3,
            3,
            3
          ]
        },
        "expected": 0
      },
      {
        "input": {
          "prices": [
            1,
            9,
            2,
            8,
            3,
            7,
            4,
            6,
            5,
            10
          ]
        },
        "expected": 9
      },
      {
        "input": {
          "prices": [
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            200
          ]
        },
        "expected": 190
      },
      {
        "input": {
          "prices": [
            10000,
            1,
            10000
          ]
        },
        "expected": 9999
      },
      {
        "input": {
          "prices": [
            2,
            1,
            4,
            5,
            2,
            9,
            7
          ]
        },
        "expected": 8
      }
    ],
    "acceptanceRate": 52,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "valid-parentheses",
    "title": "Valid Parentheses",
    "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n- Open brackets must be closed by the same type of brackets.\n- Open brackets must be closed in the correct order.\n- Every close bracket has a corresponding open bracket of the same type.",
    "difficulty": "Easy",
    "topics": [
      "String",
      "Stack"
    ],
    "companies": [],
    "tags": [
      "String",
      "Stack"
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "testCases": [
      {
        "input": {
          "s": "()"
        },
        "expected": true
      },
      {
        "input": {
          "s": "()[]{}"
        },
        "expected": true
      },
      {
        "input": {
          "s": "(]"
        },
        "expected": false
      },
      {
        "input": {
          "s": "([)]"
        },
        "expected": false
      },
      {
        "input": {
          "s": "{[]}"
        },
        "expected": true
      },
      {
        "input": {
          "s": ""
        },
        "expected": true
      },
      {
        "input": {
          "s": "("
        },
        "expected": false
      },
      {
        "input": {
          "s": "}"
        },
        "expected": false
      },
      {
        "input": {
          "s": "((((((()))))))"
        },
        "expected": true
      },
      {
        "input": {
          "s": "({[)]}"
        },
        "expected": false
      },
      {
        "input": {
          "s": "{[()()]()}"
        },
        "expected": true
      },
      {
        "input": {
          "s": ")("
        },
        "expected": false
      },
      {
        "input": {
          "s": "(){}[](){}[](){}[]"
        },
        "expected": true
      },
      {
        "input": {
          "s": "))))"
        },
        "expected": false
      }
    ],
    "acceptanceRate": 40,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "add-two-numbers",
    "title": "Add Two Numbers",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    "difficulty": "Medium",
    "topics": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "companies": [],
    "tags": [
      "Linked List",
      "Math",
      "Recursion"
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807"
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]"
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]"
      }
    ],
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "testCases": [
      {
        "input": {
          "l1": [
            2,
            4,
            3
          ],
          "l2": [
            5,
            6,
            4
          ]
        },
        "expected": [
          7,
          0,
          8
        ]
      },
      {
        "input": {
          "l1": [
            0
          ],
          "l2": [
            0
          ]
        },
        "expected": [
          0
        ]
      },
      {
        "input": {
          "l1": [
            9,
            9,
            9,
            9,
            9,
            9,
            9
          ],
          "l2": [
            9,
            9,
            9,
            9
          ]
        },
        "expected": [
          8,
          9,
          9,
          9,
          0,
          0,
          0,
          1
        ]
      },
      {
        "input": {
          "l1": [
            2,
            4
          ],
          "l2": [
            5,
            6,
            4
          ]
        },
        "expected": [
          7,
          0,
          5
        ]
      }
    ],
    "acceptanceRate": 40,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one sorted list. Return the head of the merged linked list.",
    "difficulty": "Easy",
    "topics": [
      "Linked List",
      "Recursion"
    ],
    "companies": [],
    "tags": [
      "Linked List",
      "Recursion"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      {
        "input": {
          "list1": [
            1,
            2,
            4
          ],
          "list2": [
            1,
            3,
            4
          ]
        },
        "expected": [
          1,
          1,
          2,
          3,
          4,
          4
        ]
      },
      {
        "input": {
          "list1": [],
          "list2": []
        },
        "expected": []
      },
      {
        "input": {
          "list1": [],
          "list2": [
            0
          ]
        },
        "expected": [
          0
        ]
      },
      {
        "input": {
          "list1": [
            1,
            3,
            5
          ],
          "list2": [
            2,
            4,
            6
          ]
        },
        "expected": [
          1,
          2,
          3,
          4,
          5,
          6
        ]
      }
    ],
    "acceptanceRate": 58,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "longest-common-prefix",
    "title": "Longest Common Prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\"\"`.",
    "difficulty": "Easy",
    "topics": [
      "String",
      "Trie"
    ],
    "companies": [],
    "tags": [
      "String",
      "Trie"
    ],
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "No common prefix"
      }
    ],
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of lowercase English letters"
    ],
    "testCases": [
      {
        "input": {
          "strs": [
            "flower",
            "flow",
            "flight"
          ]
        },
        "expected": "fl"
      },
      {
        "input": {
          "strs": [
            "dog",
            "racecar",
            "car"
          ]
        },
        "expected": ""
      },
      {
        "input": {
          "strs": [
            "a"
          ]
        },
        "expected": "a"
      },
      {
        "input": {
          "strs": [
            "ab",
            "a"
          ]
        },
        "expected": "a"
      }
    ],
    "acceptanceRate": 39,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "remove-duplicates-from-sorted-array",
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. Return the number of unique elements.",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "companies": [],
    "tags": [
      "Array",
      "Two Pointers"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2",
        "explanation": "nums = [1,2,_]"
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5",
        "explanation": "nums = [0,1,2,3,4,_,_,_,_,_]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100"
    ],
    "testCases": [
      {
        "input": {
          "nums": [
            1,
            1,
            2
          ]
        },
        "expected": 2
      },
      {
        "input": {
          "nums": [
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ]
        },
        "expected": 5
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3
          ]
        },
        "expected": 3
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1
          ]
        },
        "expected": 1
      }
    ],
    "acceptanceRate": 48,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "maximum-subarray",
    "title": "Maximum Subarray",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
    "difficulty": "Medium",
    "topics": [
      "Array",
      "Dynamic Programming",
      "Divide and Conquer"
    ],
    "companies": [],
    "tags": [
      "Array",
      "Dynamic Programming",
      "Divide and Conquer"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "Subarray [4,-1,2,1] has sum 6"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "testCases": [
      {
        "input": {
          "nums": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ]
        },
        "expected": 6
      },
      {
        "input": {
          "nums": [
            1
          ]
        },
        "expected": 1
      },
      {
        "input": {
          "nums": [
            5,
            4,
            -1,
            7,
            8
          ]
        },
        "expected": 23
      },
      {
        "input": {
          "nums": [
            -1,
            -2,
            -3
          ]
        },
        "expected": -1
      }
    ],
    "acceptanceRate": 50,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "companies": [],
    "tags": [
      "Math",
      "Dynamic Programming",
      "Memoization"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "1+1 or 2"
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "1+1+1, 1+2, or 2+1"
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ],
    "testCases": [
      {
        "input": {
          "n": 2
        },
        "expected": 2
      },
      {
        "input": {
          "n": 3
        },
        "expected": 3
      },
      {
        "input": {
          "n": 1
        },
        "expected": 1
      },
      {
        "input": {
          "n": 4
        },
        "expected": 5
      },
      {
        "input": {
          "n": 5
        },
        "expected": 8
      }
    ],
    "acceptanceRate": 51,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "same-tree",
    "title": "Same Tree",
    "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are the same if they are structurally identical, and the nodes have the same value.",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "DFS",
      "BFS",
      "Binary Tree"
    ],
    "companies": [],
    "tags": [
      "Tree",
      "DFS",
      "BFS",
      "Binary Tree"
    ],
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true"
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false"
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "testCases": [
      {
        "input": {
          "p": [
            1,
            2,
            3
          ],
          "q": [
            1,
            2,
            3
          ]
        },
        "expected": true
      },
      {
        "input": {
          "p": [
            1,
            2
          ],
          "q": [
            1,
            null,
            2
          ]
        },
        "expected": false
      },
      {
        "input": {
          "p": [
            1,
            2,
            1
          ],
          "q": [
            1,
            1,
            2
          ]
        },
        "expected": false
      },
      {
        "input": {
          "p": [],
          "q": []
        },
        "expected": true
      }
    ],
    "acceptanceRate": 55,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "symmetric-tree",
    "title": "Symmetric Tree",
    "description": "Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "difficulty": "Easy",
    "topics": [
      "Tree",
      "DFS",
      "BFS",
      "Binary Tree"
    ],
    "companies": [],
    "tags": [
      "Tree",
      "DFS",
      "BFS",
      "Binary Tree"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true"
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      {
        "input": {
          "root": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ]
        },
        "expected": true
      },
      {
        "input": {
          "root": [
            1,
            2,
            2,
            null,
            3,
            null,
            3
          ]
        },
        "expected": false
      },
      {
        "input": {
          "root": [
            1
          ]
        },
        "expected": true
      }
    ],
    "acceptanceRate": 51,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "plus-one",
    "title": "Plus One",
    "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit. Increment the large integer by one and return the resulting array of digits.",
    "difficulty": "Easy",
    "topics": [
      "Array",
      "Math"
    ],
    "companies": [],
    "tags": [
      "Array",
      "Math"
    ],
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]"
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]"
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]"
      }
    ],
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9"
    ],
    "testCases": [
      {
        "input": {
          "digits": [
            1,
            2,
            3
          ]
        },
        "expected": [
          1,
          2,
          4
        ]
      },
      {
        "input": {
          "digits": [
            4,
            3,
            2,
            1
          ]
        },
        "expected": [
          4,
          3,
          2,
          2
        ]
      },
      {
        "input": {
          "digits": [
            9
          ]
        },
        "expected": [
          1,
          0
        ]
      },
      {
        "input": {
          "digits": [
            9,
            9,
            9
          ]
        },
        "expected": [
          1,
          0,
          0,
          0
        ]
      }
    ],
    "acceptanceRate": 43,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  },
  {
    "slug": "sqrtx",
    "title": "Sqrt(x)",
    "description": "Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer.",
    "difficulty": "Easy",
    "topics": [
      "Math",
      "Binary Search"
    ],
    "companies": [],
    "tags": [
      "Math",
      "Binary Search"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2"
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "sqrt(8) = 2.828... rounds down to 2"
      }
    ],
    "constraints": [
      "0 <= x <= 2^31 - 1"
    ],
    "testCases": [
      {
        "input": {
          "x": 4
        },
        "expected": 2
      },
      {
        "input": {
          "x": 8
        },
        "expected": 2
      },
      {
        "input": {
          "x": 0
        },
        "expected": 0
      },
      {
        "input": {
          "x": 1
        },
        "expected": 1
      },
      {
        "input": {
          "x": 16
        },
        "expected": 4
      }
    ],
    "acceptanceRate": 36,
    "likes": 0,
    "dislikes": 0,
    "isPremium": false
  }
]